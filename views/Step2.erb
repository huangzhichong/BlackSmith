<h3>Selenium IDE</h3>

<ul>
<li><a href="http://release.seleniumhq.org/selenium-ide/1.9.0/selenium-ide-1.9.0.xpi">Selenium IDE</a> is a firefox plugin for selenium automation.</li>
<li>It provides the record and playback functions</li>
<li>the recored test cases can be exported to scripts in differnet language</li>
</ul>


<h3>Selenium WebDriver</h3>

<ul>
<li><a href="http://seleniumhq.org/projects/webdriver/">Selenium WebDriver</a> can drive a browser natively either locally or on remote machines.</li>
<li><a href="http://rubygems.org/gems/selenium-webdriver">selenium-webdriver</a> is the ruby implenmation for Selenium WebDriver framework.</li>
</ul>


<h3>Simple script in selenium-webdriver</h3>

<ul>
<li><p>below is a simple script of selenium automation.</p></li>
<li><p>this script is expecting to,</p>

<ol>
<li>open firefox</li>
<li>navigate to <a href="http://google.com">Google</a></li>
<li>input <code>Cheese!</code> and search for result</li>
<li>it will print out the page title before and after the searching</li>
<li>close firefox at the end</li>
</ol>
</li>
<li><p>copy it into a <code>.rb</code> file and have a try</p>

<pre><code># adding the selenium-webdriver gem
require 'selenium-webdriver'

# start firefox with selenium-webdriver
driver = Selenium::WebDriver.for :firefox

# navigate to http://google.com
driver.get "http://google.com"

# find the input box and type 'Cheese!'
element = driver.find_element :name =&gt; "q"
element.send_keys "Cheese!"

# submit the form
element.submit

# print out the title of current browser
puts "Page title is #{driver.title}"

# wait for the title change to start with 'cheese!'
wait = Selenium::WebDriver::Wait.new(:timeout =&gt; 10)
wait.until { driver.title.downcase.start_with? "cheese!" }

puts "Page title is #{driver.title}"

# close the browser
driver.quit
</code></pre></li>
</ul>


<h3>API workthough</h3>

<ol>
<li><p>Open a browser</p>

<pre><code># start an instance of firefox with selenium-webdriver
driver = Selenium::WebDriver.for :firefox
# :chrome -&gt; chrome
# :ie     -&gt; iexplore
</code></pre></li>
<li><p>Go to a specified URL</p>

<pre><code>driver.get 'http://google.com'
driver.navigate.to 'http://google.com'
</code></pre>

<p><code>NOTE</code> &ndash; the WebDriver may not wait for the page to load, you&rsquo;d better using explicit and implicit waits.</p></li>
<li><p>Locating Elements</p>

<ul>
<li><p><code>find_element</code> &ndash; Find the first element matching the given arguments.</p></li>
<li><p><code>find_elements</code> &ndash; Find all elements matching the given arguments</p></li>
<li><p>By ID</p>

<pre><code># example html
# &lt;input id="q"&gt;...&lt;/input&gt;

element = driver.find_element(:id, "q")
</code></pre></li>
<li><p>By Class Name</p>

<pre><code># example html
# &lt;div class="highlight-java" style="display: none; "&gt;...&lt;/div&gt;

element = driver.find_element(:class, 'highlight-java')
# or
element = driver.find_element(:class_name, 'highlight-java')
</code></pre></li>
<li><p>By Tag Name</p>

<pre><code># example html
# &lt;div class="highlight-java" style="display: none; "&gt;...&lt;/div&gt;

element = driver.find_element(:tag_name, 'div')
</code></pre></li>
<li><p>By Name</p>

<pre><code># example html
# &lt;input id="q" name='search' type='text'&gt;â€¦&lt;/input&gt;

element = driver.find_element(:name, 'search')
</code></pre></li>
<li><p>By Link Text</p>

<pre><code># example html
# &lt;a href="http://www.google.com/search?q=cheese"&gt;cheese&lt;/a&gt;

element = driver.find_element(:link, 'cheese')
# or            
element = driver.find_element(:link_text, 'cheese')
</code></pre></li>
<li><p>By Partial Link Text</p>

<pre><code># example html
# &lt;a href="http://www.google.com/search?q=cheese"&gt;search for cheese&lt;/a&gt;         
element = driver.find_element(:partial_link_text, 'cheese') 
</code></pre></li>
<li><p>By XPath</p>

<pre><code># example html
# &lt;ul class="dropdown-menu"&gt;
#   &lt;li&gt;&lt;a href="/login/form"&gt;Login&lt;/a&gt;&lt;/li&gt;
#   &lt;li&gt;&lt;a href="/logout"&gt;Logout&lt;/a&gt;&lt;/li&gt;
# &lt;/ul&gt;

element = driver.find_element(:xpath, '//a[@href='/logout']')
</code></pre>

<ul>
<li><p><code>NOTE</code> &ndash; When using Element#find_element with <code>:xpath</code>, be aware that,</p>

<ul>
<li> webdriver follows standard conventions: a search prefixed with &ldquo;//&rdquo; will search the entire document, not just the children of this current node.</li>
<li>Use &ldquo;.//&rdquo; to limit your search to the children of the receiving Element.</li>
</ul>
</li>
</ul>
</li>
<li><p>By CSS Selector</p>

<pre><code>  # example html
  # &lt;div id="food"&gt;
  #   &lt;span class="dairy"&gt;milk&lt;/span&gt;
  #   &lt;span class="dairy aged"&gt;cheese&lt;/span&gt;
  # &lt;/div&gt;

  element = driver.find_element(:css, #food span.dairy)
</code></pre></li>
</ul>
</li>
<li><p>Element&rsquo;s operation</p>

<ul>
<li><p>Button/Link/Image</p>

<pre><code>driver.find_element(:id, 'BUTTON_ID).click
</code></pre></li>
<li><p>Text Filed</p>

<pre><code># input some text
driver.find_element(:id, 'TextArea').send_keys 'InputText'
# send keyboard actions, press `ctral+a` &amp; `backspace`
driver.find_element(:id, 'TextArea').send_keys [:contol, 'a'], :backspace
</code></pre></li>
<li><p>Checkbox/Radio</p>

<pre><code># check if it is selected
driver.find_element(:id, 'CheckBox').selected?
# select the element
driver.find_element(:id, 'CheckBox').click
# deselect the element
driver.find_element(:id, 'CheckBox').clear
</code></pre></li>
<li><p>Select</p>

<pre><code># get the select element    
select = driver.find_element(:tag_name, "select")
# get all the options for this element
all_options = select.find_elements(:tag_name, "option")
# select the options
all_options.each do |option|
 puts "Value is: " + option.attribute("value")
 option.click
end

# anthoer way is using the Select class after seleniun-webdriver 2.14       
element= driver.find_element(:tag_name,"select")
select=Selenium::WebDriver::Support::Select.new(element)
select.deselect_all()
select.select_by(:text, "Edam")
</code></pre></li>
<li><p>visibility</p>

<pre><code>driver.find_element(:id,'Element').displayed?
</code></pre></li>
<li><p>get text</p>

<pre><code>driver.find_element(:id,'Element').text
</code></pre></li>
<li><p>get attribue</p>

<pre><code>driver.find_element(:id, 'Element').attribute('class')
</code></pre></li>
</ul>
</li>
<li><p>Driver&rsquo;s operation</p>

<ul>
<li><p>execute javascript</p>

<pre><code>  driver.execute_script("return window.location.pathname")
</code></pre></li>
<li><p>wait for a specific element to show up</p>

<pre><code>  # set the timeout to 10 seconds
  wait = Selenium::WebDriver::Wait.new(:timeout =&gt; 10)
  # wait 10 seconds until the element appear
  wait.until { driver.find_element(:id =&gt; "foo") }
</code></pre></li>
<li><p>implicit waits</p></li>
</ul>


<p>An implicit wait is to tell WebDriver to poll the DOM for a certain amount of time when trying to find an element or elements if they are not immediately available</p>

<pre><code>    driver = Selenium::WebDriver.for :firefox
    # set the timeout for implicit waits as 10 seconds
    driver.manage.timeouts.implicit_wait = 10

    driver.get "http://somedomain/url_that_delays_loading"
    element = driver.find_element(:id =&gt; "some-dynamic-element")
</code></pre>

<ul>
<li><p>switch between frames</p>

<pre><code>  # switch to a frame
  driver.switch_to.frame "some-frame" # name or id
  driver.switch_to.frame driver.find_element(:id, 'some-frame') # frame element

  # switch back to the main document
  driver.switch_to.default_content
</code></pre></li>
<li><p>swich between windows</p>

<pre><code>  driver.window_handles.each do |handle|
    driver.switch_to.window handle
  end
</code></pre></li>
<li><p>handle javascript dialog</p>

<pre><code>  # get the alert
  a = driver.switch_to.alert
  # operation on the alert
  if a.text == 'A value you are looking for'
    a.dismiss
  else
    a.accept
  end
</code></pre></li>
</ul>
</li>
<li><p>Cookies</p>

<ul>
<li><p>Delete cookies</p>

<pre><code>  # You can delete cookies in 2 ways
  # By name
  driver.manage.delete_cookie("CookieName")
  # Or all of them
  driver.manage.delete_all_cookies
</code></pre></li>
</ul>
</li>
</ol>
